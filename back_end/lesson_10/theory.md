## 01. Разбор домашнего задания

* Следует обратить внимание, что в классе у вас поле называется `beginDate`, но `hibernate` на основе это поля создает столбец `begin_date`
* Необходимо гарантировать, чтобы для каждого теста база была "как новая", т.е. не должно оставаться данных от прошлых тестов:
  * Для этого следует использовать аннотацию `@DirtiesContext` - она заставить контекст всего приложения для теста запустить заново
  * Мы гарантировали изолированность каждого теста

## 02. Новые классы 

* В контроллерах ВСЕГДА используем `ResponseEntity`
  * Этот класс делает ответы контроллеров более единообразными
  * Позволяет ЯВНО указать статус ответа
  * и еще много чего умеет

* `Optional` - позволяет в явном виде не работать с `null`, а использовать методы `isPresent`/`isEmpty` и кучу других
  * Повышает читаемость кода и позволяет избежать `NullPointerException`
  * Заставляет делать проверки, а не `null` ли там случаем

## 03. Реализация обработки ошибок

* Реализовать `StandardResponseDto` с единственным полем `message`
* Реализовать собственный тип ошибок `RestException`, в котором будет http-статус-код ошибки
* Теперь в случае возникновения ошибок выбрасываем `RestException` с нужным статусом
* Реализовать обработчик ошибок `RestExceptionHandler`, который будет отправлять клиенту нужный `JSON` при возникновении исключения 
  * `@ControllerAdvice` - позволяет данному классу отслеживать, что происходит в контроллерах и на это реагировать
  * `@ExceptionHandler(value = RestException.class)` - помечаем метод, который будет "перехватывать" ошибки `RestException`
  * Эта штука очень похожа на `try-catch`, но работает более глобально (на уровне всего приложения)

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/back_end/lesson_10/img/1.png)

## 04. Валидация

* Проверка входных данных, корректность чего-либо
  * Соответствует ли email нужному формату
  * Соответствует ли дата нужному формату
  * Соответствует ли пароль нужному формату
  * Не пустое ли поле для названия курса и т.д.
* Как правило, валидацию делают и на backend и на frontend
* Чтобы валидация заработала, нужно подключить зависимость:

```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

* Данная зависимость состоит из двух важных компонентов:
  * `hibernate-validator` - непосредственно тот компонент, который выполняет валидацию данных
  * `jakarta-validation-api` - аннотации для валидации

* Повесить аннотацию `@Valid` в контроллере на объект, которых хотим валидировать

### Аннотации для валидации

* `@NotNull` - поле точно должно присутствовать в HTTP-запросе, его нельзя просто убрать
* `@NotBlank` - значение поля не может быть представлено набором пробелов
* `@NotEmpty` - значение поля не может быть пустой строкой
* `@Size(min = 5, max = 1000)` - минимальная длина поля (либо строка, либо коллекция) - 5 символов, максимальная - 1000
* `@Min(value = 0)/@Max(value = 200)` - границы для числовых полей
* `@Pattern` - проверяет по регулярному выражению

### Обработка ошибок валидации

* `ObjectError` - дает информацию об объекте в целом (в нашем случе - `newCourseDto`)
* `FieldError` - дает информацию о конкретном поле, `FieldError` можно получить из `ObjectError`

* Мы хотим, чтобы информация об ошибках валидации возвращалась клиенту, желательно в таком формате:

```json
{
  "errors": [
    {
      "field": "price",
      "rejectedValue": "10000.0",
      "message": "must be less than or equal to 200"
    },
    {
      "field": "endDate",
      "rejectedValue": "2023-2000-02",
      "message": "must match ^(?:(?:19|20)\d\d)-(?:0[1-9]|1[0-2])-(?:0[1-9]|1\d|2\d|3[0-1])$"
    }
  ]
}
```

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/back_end/lesson_10/img/2.png)