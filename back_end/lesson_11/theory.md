## 01. Повторение

* `ValidationExceptionHandler` - это глобальный `try-catch` (грубо говоря) для ошибок валдиации
* Задача этого класса - перехватить ошибку валидации и сформировать понятный ответ для клиента
* `MethodArgumentNotValidException` - тип ошибки, который возникает при валидации. Эту ошибку выбрасывает `Spring`
* Соответственно, метод `handleValidationException` перехватывает эту ошибку, забирает из этой ошибки информацию по всем
  полям, с которыми возникла проблема
    * и возвращает ответ клиенту

### Разбор некоторых фрагментов кода ValidationExceptionHandler более подробно

* `e.getBindingResult()` - `binding` - связывание входящего json и вашей DTO, в `bindingResult` находятся результаты
  этого связывания
* нас интересуют только ошибки связывания, поэтому: `List<ObjectError> errors = e.getBindingResult().getAllErrors();`
    * т.е. получаем все ошибки связывания, которые имеют тип `ObjectError`
    * `ObjectError` - это одна ошибка валидации
* Есть нюанс. Ошибки бывают двух типов:
    * `ObjectError` - поломан весь объект целиком (пока мы не знаем, что это такое)
    * `FieldError` - ошибка в конкретном поле
    * Так устроено, что `FieldError` - это потомок `ObjectError`
    * Поэтому, чтобы получить информацию по конкретному полю, нужно сделать явное нисходящее преобразование от предка к
      потомку: `FieldError fieldError = (FieldError)error;`
* Похожий случай:

```
Scanner scanner = new Scanner(System.in);
Object o = scanner;
Scanner scannerFromObject = (Scanner)o;
o.nextLine();
scannerFromObject.nextLine();
```

## 02. Задача регистрации

* Метод запроса:

```
POST /api/users/register
```

```
{
   "email": "sidikov.marsel@gmail.com",
   "password": "qwerty007"
}    
```

* После регистрации создается пользователь с ролью `USER`, в ответе нужно сообщить id созданного пользователя

* Нюанс - во многих СУБД таблица `USER` уже зарезервирована, поэтому для своей таблицы нужно придумать другое название
* На каждый `endpoint` - документация, валидация, тесты, обработка ошибок

## 03. Подключение PostgreSQL

* [Ссылка для скачивания](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads)
* В `pom.xml` нужно добавить:

```xml

<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
</dependency>
```

## 04. Хеширование паролей

* Мы не храним пароли в чистом виде, мы должны их хешировать
* Потому что если нашу базу данных взломают, то у хакеров будут пары вида `email-пароль`
* Люди часто используют одни и те же пароли, поэтому таким образом мы их подставляем
* Мы будем хешировать с помощью алгоритма `BCrypt`

* Необходимо подключить:

```xml
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-core</artifactId>
</dependency>
```

### Как работает алгоритм хеширования/кодирования BCrypt

* `Qwerty007!` -> `$2a$10$[UytWtZwAED2ndPrIki38R.][o/Nm8lB/M.NI7gZuOVZLeS5ZUoTSp.K]`

* `$2a$10` - служебная информация, говорит нам от том, что мы шифровали алгоритмом `Bcrypt`
* `UytWtZwAED2ndPrIki38R.` - случайная соль
* `o/Nm8lB/M.NI7gZuOVZLeS5ZUoTSp.K` - хеш пароля

1. На вход подается пароль `Qwerty007!`
2. Генерируется случайная последовательность символов длины 22 - соль - `UytWtZwAED2ndPrIki38R.`
3. Вычисляется хеш-код (по особому алгоритму) от строки `Qwerty007!.UytWtZwAED2ndPrIki38R.`
4. Получаем `o/Nm8lB/M.NI7gZuOVZLeS5ZUoTSp.K` (здесь замешана соль, поэтому исходный пароль невозможно получить)
5. Формируем итоговый вариант "пароля" - служебная информация + соль, которую использовали + полученный пароль

### А в обратную сторону?

* Пользователь вводит email и пароль `Qwerty007!`
* Вы по email находите хеш-пароля, который соответствует этому email
  * Получаем пару - `Qwerty007!` и из базы данных `$2a$10$UytWtZwAED2ndPrIki38R.o/Nm8lB/M.NI7gZuOVZLeS5ZUoTSp.K`
  * Нужно проверить, можно ли из пароля, который ввел пользователь получить хеш, который у вас в базе
* Берем пароль, который ввел пользователь, берем соль из пароля в базе данных - `UytWtZwAED2ndPrIki38R.`
* Формируем хеш на основе пароля, который ввел пользователь и соли из базы `Qwerty007!.UytWtZwAED2ndPrIki38R.`
* Получаем хеш - `o/Nm8lB/M.NI7gZuOVZLeS5ZUoTSp.K` и сравниваем с тем, что хранится у нас в базе.

## Почему алгоритм хеширования безопасен?

* Пусть есть число 128, и получить его можно разными способами:
  * 120 + 8
  * 256 - 128
  * и т.д.
* Хеш - это число 128, есть миллион вариантов, как его получить, но вы не знаете, какой использовался, чтобы получить два исходных числа

