# Связи между сущностями

* ОО-связи
* Реляционные связи

## Рассмотрим предметную область:

* Владельцы машин
* Машины
* Водители машин (арендаторы машин)

## 01.  Реляционные связи (SQL)

### Один-ко-многим

* Как сделать так, чтобы у машины был владелец?
* Нам необходимо у машины хранить id владельца из таблицы `account`
* Такая связь называется `Многие-к-Одному`/`Many-To-One`, `Один-ко-Многим`/`One-To-Many`
* Почему так называется? Потому что у одного владельца может быть много машин, и у многих машин только один владелец
* Чтобы гарантировать, что у машины будет указан существующий владелец, необходимо использовать внешний ключ (`foreign key`)
* `foreign key (owner_id) references account(id)` - мы говорим, что колонка `owner_id` является внешним ключом
  * Ссылается на колонку `id` в таблице `account`
  * Вы не сможете поставить в колонку `owner_id` значение, которого нет в таблице `account`

### Многие-ко-многим

* Как сделать так, чтобы можно было обозначить, что какой-то человек водит какую-то машину, но не является владельцем
* Много человек могут "брать в аренду" много машин, и при этом много машин может быть арендовано многими людьми
* Такая связь называется `Многие-ко-многим`/`Many-to-Many`
* Ее в SQL можно реализовать с помощью третьей таблицы с двумя внешними ключами

## 02. Объектно-ориентированные связи

* А как сделать аналогию, только в приложении? Как правильно связать между собой классы?
* Важно помнить, что `класс ~ таблица`, а `объект ~ строка` таблицы.
* Как это реализуется?

### Один-ко-многим

* В классе, который "Один", нужно сделать множество/список объектов типа "Многие"
* В классе, который "Многие", нужно сделать один объект типа "Один"

### Многие ко многим

* В обоих классах создаем множества/списки другого типа

## 03. Реализация связей в образовательном центре

* Пользователь
  * Список курсов, на которые он записан
* Курс
  * Список уроков, которые включены в этот курс
  * Список студентов, которые включены в этот курс
* Урок
  * Курс, к которому принадлежит урок

### Многие-к-одному/Один-ко-многим

```
@ManyToOne
@JoinColumn(name = "course_id", nullable = false)
private Course course;
```

* `@ManyToOne` - аннотация `JPA`, которой бы обозначаем связь `Многие к одному`
* `@JoinColumn` - говорим, что нужно создать внешний ключ `course_id`
* Hibernate автоматически создаст внешний ключ на таблицу с курсами.

```
@OneToMany(mappedBy = "course")
private Set<Lesson> lessons;
```

* `@OneToMany` - аннотация JPA, которая ставится в связи "Один ко многим" в сущности, которая "одна"
* `mappedBy` - означает, что в дочерней сущности (в уроке) уже прописана логика этой связи над полем `course`
  * и мы просто хотим использовать ее
* В множество `lessons` будут автоматически загружаться уроки, у которых стоит тот же `course`, что вы и запросили

### Многие-ко-многим

```
@ManyToMany
    @JoinTable(
            name = "student_course",
            joinColumns =
            @JoinColumn(name = "student_id", nullable = false, referencedColumnName = "id"),
            inverseJoinColumns =
            @JoinColumn(name = "course_id", nullable = false, referencedColumnName = "id"),
            uniqueConstraints = @UniqueConstraint(columnNames = {"student_id", "course_id"})
    )
    private Set<Course> courses;
```

* `@ManyToMany` - обозначает связь многие-ко-многим
* `@JoinTable` - говорит о том, что нам нужна третья таблица `student_course` с двумя внешними ключами:
  * `joinColumns` - указываем первую колонку (первый внешний ключ), она не может null, называется `student_id` и ссылается на `id` таблицы `account`
  * `inverseJoinColumns` - указываем вторую колонку (второй внешний ключ), она не может быть null, называется `course_id` и ссылается на `id` таблицы `course`
  * `uniqueContstraints` - указываем колонки, которые должны быть в паре уникальными в этой таблице
* В чем разница между `joinColumns` и `uniqueContstraints`
* В `joinColumns` пишем ссылку на ту таблицу, из класса которой мы прописываем связь
* Сейчас мы описывали связь в классе `User`, поэтому первая колонка ссылается на `User`

## 04. Реализация endpoint-а для добавления урока в курс

* По правилам REST нужно endpoint назвать так:

```
POST /api/courses/{id-курса}/lessons

{
  "name": "Java - Введение",
  "startTime": "9:30",
  "finishTime": "13:00",
  "dayOfWeek": "MONDAY"
}
```

## 05. Реализация endpoint-а для получения всех уроков какого-либо курса

* По правилам REST можно endpoint назвать так:

```
GET /api/courses/{id-курса}/lessons
```

### Тезисы

* Существуют связи "Многие-к-одному"/"Один-ко-многим" и "Многие-ко-многим"
* На уровне SQL-базы данных:
  * Многие-к-одному реализуются через один внешний ключ на другую таблицу
  * Многие-ко-многим с помощью третей таблицы с двумя внешними ключами
* На уровне Java-кода:
  * Многие-к-одному реализуются через `Set` в одном классе и через единственный экземпляр в другом. 
  * Многие-ко-многим реализуются через `Set` в обоих классах
* Необходимо использовать соответствующие аннотации JPA для того, чтобы Hibernate мог сгенерировать необходимые таблицы и связи между ними:
  * `@OneToMany`/`@ManyToOne`/`@JoinColumn` - для один-ко-многим и многие-к-одному соответственно
  * `@ManyToMany/@JoinTable` - для многие-ко-многим
* Если мы хотим реализовать endpoint-ы для работы с этими сущностями, то их следует именовать вот так:
  * `/родительская сущность/{id-родительской сущности}/дочерняя сущность`
  * `/cars/10/drivers` - все водители машины с id = 10
  * `/drivers/5/cars` - все машины водителя с id = 5
  * `/courses/4/lessons` - все уроки четвертого курса и т.д.