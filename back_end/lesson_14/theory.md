# Повторение

## 01. HTTP

* Протокол общения между сервером и клиентом
* Сервер (серверное приложение) - это приложение, которое размещено на общедоступном (или доступном в конкретной сети) компьютере (сервере).
* Клиент (клиентское приложение) - это приложение, которое запущено на стороне пользователя
* Клиентом может быть мобильное приложение, браузер, либо Desktop-приложение
* Любое из этих приложений может отправлять HTTP-запрос на сервер и получать ответ

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/back_end/lesson_14/img/1.png)

### Структура HTTP-запроса

* `URL`, куда направляется запрос, например:

```
http://my-application.com:8080/api/courses
```

* `Метод запроса` (`http methods`) (GET, POST, PUT, DELETE и т.д.), вы можете использовать любой из них в зависимости от семантики запроса.

* `Параметры запроса` (`request parameters`) (могут размещаться как в теле запроса - `PUT`, `POST`, так и в URL - `GET`, `DELETE`)

```
http://my-application.com:8080/api/courses?teacherId=8&status=DRAFT
```

* `Заголовки запроса` (`request headers`) - нужны для того, чтобы передать серверу какую-либо сопроводительную информацию
    * `Content-type` - показывает, в каком формате вы отправляете запрос, чтобы сервер мог распознать этот контент и правильно обработать:
      * `application/json`
    * `Cookie` - информация, которая помогает серверу понять кто вы

* `Тело запроса` (`request body`, только для `POST`, `PUT`, `PATCH`) - информация, которую отправляет клиент серверу

### Структура HTTP-ответа

* `Статус ответа` (`HTTP Status code`) - нужен клиенту, чтобы понять, как прошел его запрос
  * `200` - OK (все хорошо)
  * `201` - CREATED (создано, как правило для POST-запросов)
  * `400` - BAD REQUEST (запрос не может быть обработан сервером, потому что он неправильно сформирован)
  * `404` - NOT FOUND
  * `500` - INTERNAL SERVER ERROR (что-то пошло не так на сервере)

* `Тело ответа` (`Reponse body`) - информация, которую сервер направляет клиенту, например JSON-список пользователей

* `Заголовки ответа` - сопроводительная информация от сервера для клиента
  * `Content-type` - показывает, в каком формате пришли данные от сервера, чтобы клиент мог их правильно отобразить/обработать
    * `application/json`
    * `image/jpeg`
    * `text/html`
  * `Location` - заставляет браузер перейти на другую страницу
  * `Set-Cookie` - заставляет браузер запомнить какие-то куки, чтобы потом их отправлять на сервер

## 02. Frontend vs Backend

* `Backend` - называют часть вашего сервиса, которая представляет собой кодовую базу серверного приложения
  * Либо так называют само приложение
  * Т.е. на практике серверное приложение и его код могут называть `Сервером` или `Backend`

* `Frontend` - называют часть вашего сервиса, которая представляет собой кодовую базу для клиентского браузерного приложения
  * Иногда сопоставляют `Frontend` и `Клиент`, но это не совсем правильно, потому что:
    * `Frontnend` - это может быть React-приложение, которое загружается в браузер и там уже становится клиентским
  * Но, как правило, когда говорят `я пишу Frontend` имеют в виду и React-приложение и клиент, который будет загружен в браузер

## 03. API

* API - набор публичных методов, позволяющих что-то сделать с чем-то
  * API есть у Spring - это набор аннотаций, классов и т.д.
  * API есть у Google - это например поисковые функции
  * API есть у серверного приложения - это набор методов и URL-ов по которым мы можем с ним взаимодействовать
  * Например, у серверного приложения Google - `GET https://google.com/search?q={запрос}`
* Когда вы пишете Backend, вы как раз предоставляете клиенту (фронтэнду) API для работы с вашим Backend-ом

## 04. REST API

* Набор рекомендации (правил) как следует оформлять ваш API
* Некоторые правила и рекомендации:
  * Использовать HTTP-методы
  * Использовать правильные статусы ответов
  * Использовать формат JSON
  * URL-ы называть с точки зрения `ресурсов` - `courses/1/lesson` - все уроки курса с ID = 1

* Добавление пользователя с ID = 5 в друзья к человеку с ID = 8
  * Не REST: `GET users/addFriend/friendId=8&userId=5`
    * Используется метод `GET`, хотя по семантике это добавление
    * В URL используется глагол `addFirend` (желательно избегать, только в крайних случаях)
    * Вместо того, что бы данные передавать в теле, отправляем их через параметры запроса в URL
  * REST: `POST /users/5/friends` и в теле запроса `{ "newFriendId" : 8 }`

* [Пример](https://developer.twitter.com/en/docs/api-reference-index)

## 05. Структура приложения

### Зависимости (`dependencies`)

* `spring-security-core` - нужна для хеширования паролей (BCrypt)
* `postgresql` - для того, чтобы ваше приложение работало с БД типа PostgresSQL
* `spring-boot-starter-validation` - для работы валидации в вашем проекте
* `springdoc-openapi-ui` - чтобы работал `Swagger`
* `spring-boot-starter-test` - для написания модульных и интеграционных тестов для Spring Boot -приложения
* `lombok` - генерация getters/setters/toString/equalsAndHashCode
* `h2` - inMemory база данных для тестирования
* `spring-boot-starter-web` - чтобы в целом у вас работало web-приложение (контроллеры, конвертация в/из JSON)
* `spring-boot-starter-data-jpa` - чтобы работали Jpa-репозитории и ваши модели

### Слои (layers)

* `controllers` - классы для обработки HTTP-запросов на стороне сервера
* `dto` - классы, объекты которых либо конвертируются в JSON либо из JSON, мы их создаем, чтобы сделать удобнее клиенту и не отправлять лишнего
* `exception` - нужно для того, чтобы красиво показывать ошибки клиенту
  * `RestException` - собственный класс ошибок, который позволяет задать статус ответа и текст ошибки
  * `RestExceptionHandler` - перехватчик ошибок, он перехватывает какой-либо REST Exception и преобразует ее в нормальный JSON-ответ
* `models` - иногда называют `entities/domain`, модели предметной области, сущности с которыми вы работаете, как правило, они сохраняются в базе данных
* `repositories` - инструменты для взаимодействия с хранилищем данных
* `services` - бизнес-логика
* `validation` - нужен для валидации входных данных
  * `dto` - тут храним объекты, которые красиво будут показывать список ошибок валидации
  * `handler`
    * `ValidationExceptionHandler` - похож на `RestExceptionHandler`, перехватывает `MethodArgumentNotValidException` (ошибки валидации) и преобразует их в красивый ответ

## 06. Разбор аннотаций по компонентам

### `Swagger`

* `@Tags` - позволяет сгруппировать Endpoint-ы
* `@Operation` - позволяет дать описание Endpoint-у
* `@ApiResponses` - позволяет описать возможные варианты ответа на этот Endpoint
* `@Schema` - позволяет задокументировать DTO и их свойства
* `@Parameter` - позволяет задокументировать параметр запроса или часть пути

### `Spring Web`

* `@RestController` - помечаем класс, который будет обрабатывать HTTP-запросы и возвращать в качестве ответа JSON
* `@RequestMapping` - можно вешать и на методы, но мы вешаем на контроллер, чтобы задать общий префикс для всех запросов, который здесь обрабатываем
* `@PostMapping` - помечаем метод, который должен обработать POST-запрос (аналогично для других HTTP-методов)
* `@RequestBody` - необходимо, чтобы вытащить тело запроса в формате JSON
* `@PathVariable` - позволяет получить часть URL
* `@RequestParam` - позволяет получить параметр запроса (через `?`, например - `/api/friends?age=25`), `@RequestParam("age") int age`
* `@ControllerAdvice`/`@ExceptionHandler` - необходимо для перехвата ошибок и отправке ответа в нужном формате

### `lombok`

* `@Data` - генерирует сеттеры, геттеры, `toString`, `equals`, `hashCode`
* `@NoArgsConstructor` - конструктор без параметров
* `@AllArgsConstructor` - конструктор со всеми параметрами (включаются все поля класса)
* `@Builder` - генерирует билдер :) Позволяет создавать объекты по частям, инициализируя только нужные поля
* `@RequiredArgsConstructor` - конструктор с параметрами, которые соответствуют только final-полям

### `Java Persistence API` (с ними работают Spring Data JPA, Hibernate)

* `@Entity` - позволяет сделать таблицу на основе этого класса и в целом позволяет Hibernate с ним работать
* `@Table` - позволяет задать собственное имя таблицы, которая будет создана на основе класса
* `@Id` - показывает, где находится идентификатор сущности
* `@GeneratedValue` - позволяет указать логику генерации значения
* `@Column` - позволяет задать собственные настройки колонки (например размер, уникальность, `not-null`)
* `@Enumerated` - показывает, как мы хотим хранить enum-значения в базе (либо числом, либо строкой)
* `@ManyToMany` - для обозначения связи многие-ко-многим
* `@OneToMany/@ManyToOne` - для обозначения связи один-ко-многим/многие-к-одному
* `@JoinTable` - показывает, как нужно создать третью таблицу для многие-ко-многим
* `@JoinColumn` - указывает на внешний ключ

### `Java Validation API` (с ними работают Spring Validation, Hibernate Validator)

* `@Valid` - вешаем на объект, который необходимо проверить
* `@NotEmpty` - не может быть пустой строкой (или пустой коллекцией)
* `@NotBlank` - не может быть заполнено пробелами
* `@NotNull` - не может быть null
* `@Email` - должен быть в формате Email-адреса
* `@Pattern` - должен соответствовать регулярному выражению
* `@Size` - размер должен быть в указанном диапазоне
* `@Min/@Max` - максимально-возможное/минимально-возможное значение

### Spring

* `@Component`/`@Service`/`@Repository` - помечаем классы, на основе которых Spring создает бины
* `@Bean` - помечаем метод, результат работы которого - бин
* `@Autowired` - ставим на поле, конструктор или сеттер - показываем, что в это место должен быть выполнен инджект-бина

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/back_end/lesson_14/img/2.png)