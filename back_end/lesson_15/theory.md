## 01. Безопасность в приложении

* Аутентификация - процесс, при котором приложение запрашивает логин и пароль и проверяет их корректность 
  * проверка подлинности данных пользователя
* Авторизация - процесс, при котором приложение проверяет права пользователя на выполнение каких-либо операций
  * например, проверка на возможность получения пользователем всех курсов по адресу `/courses`
* HTTP-сессия - это некоторый объект, который мы храним на сервере, с которым может быть ассоциирован конкретный пользователь

## 02. Процесс аутентификации на основе сессии

* Сначала клиент отправляет POST-запрос на сервер по адресу `api/login`
* В теле запроса клиент передает данные для аутентификации (например, email и пароль)
* Сервер проверяет корректность этих данных (находит пользователя в базе, хеширует введенный пароль, сравнивает с тем, который есть в базе)
* Если данные для входа корректные, то сервер в оперативной памяти создает объект сессии
  * ассоциирует с этим объектом данные пользователя
  * назначает объекту идентификатор
  * отправляет клиенту этот идентификатор, который на клиенте сохраняется в куках

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/back_end/lesson_15/img/1.png)

## 03. Процесс авторизации на основе сессии

* Клиент посылает свой запрос вместе с кукой, которая содержит идентификатор сессии
* Сервер по этому идентификатору находит сессию в хранилище и получает ее атрибуты (в нашем случае это пользователь)
* Получив пользователя, сервер проверяет его роль и доступ к определенному endpoint на основе правил (опишем далее)
* Клиенту возвращается либо запрошенный ресурс, либо 403-статус (Запрещено)

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/back_end/lesson_15/img/2.png)

### Замечания

1. Данный способ не характерен для REST API, в котором чаще применяется подход, основанный на JWT-токенах
2. Мы используем данный подход, потому что он проще в настройке, понимании и реализации
3. JWT-токены возможно изучим при реализации проектов
4. На собеседовании могут спросить, а где в итоге хранится сессия? Правильный ответ: на сервере, на клиенте мы храним только ее идентификатор
5. В атрибутах сессии необязательно должен хранится текущий пользователь, там может быть что угодно
6. Если приложение перезапустить, то сессия сбрасывается и всем пользователям нужно заново войти
7. Если пользователь сделает logout, то в этом случае тоже сбрасывается
8. Время "жизни" в простое сессии Spring Boot зависит от настроек приложения, по умолчанию - 30 минут
9. Почему сессии - это удобно? На frontend не нужно контролировать сохранение идентификатора сессии и его отправку
10. Проблема сессий - их просто так не адаптируешь для других типов клиентов (например, мобильных приложений)
11. Если мы хотим сделать так, чтобы при перезагрузке сервера сессии не очищались и всем пользователям не приходилось заново логиниться - нужно хранить сессии в БД (обычно используют REDIS)

## 04. Настройка безопасности Spring Boot с Spring Security

* При подключении Spring Boot Starter Security у вас есть:
  * Страница входа
  * Защита всех endpoints
  * Логин `user`
  * Пароль генерируется в консоли
* Но мы хотим, чтобы люди заходили под своими логинами и паролями

### Шаги по настройке Spring Security

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/back_end/lesson_15/img/3.png)

1. Создать класс-реализацию интерфейса `UserDetails`
   * Данный класс нужен для того, чтобы адаптировать вашего пользователя под безопасность Spring Security
   * По сути, это адаптер нашего класса `User` для `Spring Security`
   * В нашем случае это класс `AuthenticatedUser`
2. Создать класс-реализацию интерфейса `UserDetailsService`
   * Данный класс нужен для того, чтобы показать Spring Security откуда брать пользователя для проверки
   * В нашем случае это класс `UserDetailsServiceImpl`
3. Настройка конфигурации Spring Security (см. комментарии в коде)
4. Навести порядок с ответами на запросы

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/back_end/lesson_15/img/4.png)

### Правильные ответы на неправильные запросы

### Что происходит сейчас?

1. Если мы не аутентифицированы, то к нам приходит страница логина на запросы `api`
    * Это плохо, потому что у нас для этих случаев будет работать frontend, он сам покажет нужную страницу
    * Нам просто нужно в JSON-ответе указать, что запрос не аутентифицирован и мы не можем дать доступ и указать статус `401`

### Для вас

1. Создать бин на `PasswordEncoder` 
2. Прописать в application.properties `logging.level.org.springframework.security=DEBUG`
3. Скопировать мой пакет `security`