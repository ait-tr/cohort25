# Процесс

* Процесс = программа
* Одновременно могут работать несколько процессов - Chrome, IntelliJ IDEA, Zoom
* В каждом процессе есть потоки.

# Потоки (Threads)

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/basic_programming/lesson_62/img/1.png)

* Поток - выделенный код, который может выполняться внутри вашей программы, одновременно с другими потоками
* `Thread` - встроенный класс, который содержит необходимую функциональность для работы с потоками.
* Если мы хотим сделать собственный поток, нужно наследовать класс `Thread` и переопределить метод `run()`
* В методе `run` нужно написать код, который должен выполняться в отдельном потоке.
* Для запуска потока необходимо вызвать метод `start()`
* Потоки недетерминированы (неоднозначны) - работают "случайно"
* `Runnable` - интерфейс, который удобно использовать вместе с потоками, содержит только метод `run`

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/basic_programming/lesson_62/img/2.png)

## Разница между процессами и потоками

* Процессы - полностью независимы друг от друга, у них разная память
* Потоки - зависимы друг от друга, работают в одной памяти (могут использовать общие переменные)

## Конкурентность и параллелизм

* Параллелизм - свойственен процессам. Программы могут полностью независимо и одновременно работать друг с другом.
* Конкурентность - свойство потоков. Процессор сам определяет, какой поток может работать в данный момент времени.

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/basic_programming/lesson_62/img/3.png)

## Особенности работы потоков

* Если наш родительский поток `main` сначала создает два объекта потоков, потом их запускает, а потом выводит что-то свое, получаем:

```
main Human
main Human
main Human
Thread-0 Egg
Thread-1 Hen
```

![image](https://raw.githubusercontent.com/ait-tr/cohort25/main/basic_programming/lesson_62/img/4.png)

* Пока два побочных потока запускались, `main` успел вывести информацию

## Некоторые методы

* `Thread.currentThread().getName()` - получить имя текущего потока
* `a.join()` - если `a.join()` был вызван в родительском потоке, например в `main`, то родительский поток будет ждать завершения `a`
* `Thread.sleep(500);` - усыпляем текущий поток на 500 миллисекунд

## Проблема мужа и жены

* Поскольку один и тот же код выполняется одновременно (конкурентно) двумя потоками, то возможны четыре ситуации:

1. Все хорошо - закончил покупки муж.
2. Все хорошо - закончил покупки жена.
3. Все плохо - пока муж шел покупать, жена успела сделать покупку
4. Все ОЧЕНЬ плохо - пока жена шла покупать, муж успел сделать покупку

* Как это исправить? Для таких ситуаций существует механизм синхронизаций.
* ТОЛЬКО ОДИН ПОТОК МОЖЕТ ВЫПОЛНЯТЬ КАКОЙ-ЛИБО НАБОР ИНСТРУКУЦИЙ В ЕДИНИЦУ ВРЕМЕНИ

```
synchronized (x) {
    A; B; C;
}
```

* x - объект синхронизации (мьютекс, одноместный семафор) - если какой-то поток занял мьютекс, другой поток не может работать
* В таком случае, гарантированно, что второй поток не вмешается в последовательность A->B->C первого потока.

## ExecutorService - ThreadPool

* Пул потоков
  * Очередь задач
  * Запущенные потоки

* Пул потоков заранее создает несколько потоков и запускает их.
* Каждая новая задача встает в очередь и обрабатывается освободившимся потоком